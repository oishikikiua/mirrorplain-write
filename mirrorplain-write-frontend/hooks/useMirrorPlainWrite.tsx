"use client";

/**
 * Custom hook for interacting with MirrorPlainWrite contract
 * Handles encrypted entry submission and goal management
 */

import { useState, useCallback, useEffect } from "react";
import { ethers, Contract } from "ethers";
import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";

// These will be auto-generated by scripts/genabi.mjs
// @ts-ignore - will be generated
import { MirrorPlainWriteABI } from "@/abi/MirrorPlainWriteABI";
// @ts-ignore - will be generated
import { MirrorPlainWriteAddresses } from "@/abi/MirrorPlainWriteAddresses";

export interface EntryData {
  words: string;
  duration: string;
  timestamp: number;
}

export function useMirrorPlainWrite(
  fhevmInstance: FhevmInstance | undefined,
  signer: ethers.JsonRpcSigner | undefined,
  account: string | undefined,
  chainId: number | undefined
) {
  const [contract, setContract] = useState<Contract | undefined>(undefined);
  const [contractAddress, setContractAddress] = useState<string | undefined>(undefined);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | undefined>(undefined);

  // Initialize contract
  useEffect(() => {
    if (!signer || !chainId) {
      setContract(undefined);
      setContractAddress(undefined);
      return;
    }

    try {
      const addressInfo = (MirrorPlainWriteAddresses as any)[chainId.toString()];
      if (!addressInfo || !addressInfo.address || addressInfo.address === ethers.ZeroAddress) {
        console.warn(`[useMirrorPlainWrite] No deployment found for chainId ${chainId}`);
        setContract(undefined);
        setContractAddress(undefined);
        return;
      }

      const addr = addressInfo.address;
      const abi = (MirrorPlainWriteABI as any).abi;
      const contractInstance = new Contract(addr, abi, signer);
      
      setContract(contractInstance);
      setContractAddress(addr);
      console.log(`[useMirrorPlainWrite] Contract initialized at ${addr}`);
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to initialize contract:", e);
      setError(e instanceof Error ? e : new Error(String(e)));
    }
  }, [signer, chainId]);

  // Submit entry
  const submitEntry = useCallback(async (
    wordCount: number,
    durationSeconds: number,
    timestamp: number
  ): Promise<boolean> => {
    if (!contract || !fhevmInstance || !signer || !account) {
      setError(new Error("Contract or FHEVM instance not ready"));
      return false;
    }

    setIsLoading(true);
    setError(undefined);

    try {
      console.log("[useMirrorPlainWrite] Encrypting entry data...");
      
      // Create encrypted inputs
      const wordsInput = fhevmInstance.createEncryptedInput(contractAddress!, account);
      wordsInput.add32(wordCount);
      const encryptedWords = await wordsInput.encrypt();

      const durationInput = fhevmInstance.createEncryptedInput(contractAddress!, account);
      durationInput.add32(durationSeconds);
      const encryptedDuration = await durationInput.encrypt();

      console.log("[useMirrorPlainWrite] Submitting entry to contract...");
      
      const tx = await contract.submitEntry(
        encryptedWords.handles[0],
        encryptedWords.inputProof,
        encryptedDuration.handles[0],
        encryptedDuration.inputProof,
        timestamp
      );

      console.log("[useMirrorPlainWrite] Waiting for transaction...", tx.hash);
      const receipt = await tx.wait();
      
      console.log("[useMirrorPlainWrite] Entry submitted successfully");
      return receipt.status === 1;
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to submit entry:", e);
      setError(e instanceof Error ? e : new Error(String(e)));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [contract, fhevmInstance, signer, account, contractAddress]);

  // Set goals
  const setGoals = useCallback(async (
    weeklyGoal: number,
    monthlyGoal: number
  ): Promise<boolean> => {
    if (!contract || !fhevmInstance || !signer || !account) {
      setError(new Error("Contract or FHEVM instance not ready"));
      return false;
    }

    setIsLoading(true);
    setError(undefined);

    try {
      const weeklyInput = fhevmInstance.createEncryptedInput(contractAddress!, account);
      weeklyInput.add32(weeklyGoal);
      const encryptedWeekly = await weeklyInput.encrypt();

      const monthlyInput = fhevmInstance.createEncryptedInput(contractAddress!, account);
      monthlyInput.add32(monthlyGoal);
      const encryptedMonthly = await monthlyInput.encrypt();

      const tx = await contract.setGoals(
        encryptedWeekly.handles[0],
        encryptedWeekly.inputProof,
        encryptedMonthly.handles[0],
        encryptedMonthly.inputProof
      );

      const receipt = await tx.wait();
      console.log("[useMirrorPlainWrite] Goals updated successfully");
      return receipt.status === 1;
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to set goals:", e);
      setError(e instanceof Error ? e : new Error(String(e)));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [contract, fhevmInstance, signer, account, contractAddress]);

  // Allow mentor
  const allowMentor = useCallback(async (mentorAddress: string): Promise<boolean> => {
    if (!contract) {
      setError(new Error("Contract not ready"));
      return false;
    }

    setIsLoading(true);
    setError(undefined);

    try {
      const tx = await contract.allowMentor(mentorAddress);
      const receipt = await tx.wait();
      console.log("[useMirrorPlainWrite] Mentor authorized successfully");
      return receipt.status === 1;
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to authorize mentor:", e);
      setError(e instanceof Error ? e : new Error(String(e)));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [contract]);

  // Revoke access
  const revokeAccess = useCallback(async (mentorAddress: string): Promise<boolean> => {
    if (!contract) {
      setError(new Error("Contract not ready"));
      return false;
    }

    setIsLoading(true);
    setError(undefined);

    try {
      const tx = await contract.revokeAccess(mentorAddress);
      const receipt = await tx.wait();
      console.log("[useMirrorPlainWrite] Access revoked successfully");
      return receipt.status === 1;
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to revoke access:", e);
      setError(e instanceof Error ? e : new Error(String(e)));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [contract]);

  // Decrypt user totals
  const decryptTotals = useCallback(async (): Promise<{ words: bigint; time: bigint } | null> => {
    if (!contract || !fhevmInstance || !signer || !account || !contractAddress) {
      return null;
    }

    try {
      console.log("[useMirrorPlainWrite] Generating fresh decryption signature...");
      
      // Generate new keypair and signature (no cache)
      const { publicKey, privateKey } = fhevmInstance.generateKeypair();
      const sig = await FhevmDecryptionSignature.new(
        fhevmInstance,
        [contractAddress],
        publicKey,
        privateKey,
        signer
      );

      if (!sig) {
        console.error("[useMirrorPlainWrite] Failed to get decryption signature");
        return null;
      }

      const totalWordsHandle = await contract.getUserTotalWords(account);
      const totalTimeHandle = await contract.getUserTotalTime(account);

      const decrypted = await fhevmInstance.userDecrypt(
        [
          { handle: totalWordsHandle, contractAddress },
          { handle: totalTimeHandle, contractAddress }
        ],
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      return {
        words: decrypted[totalWordsHandle] as bigint,
        time: decrypted[totalTimeHandle] as bigint
      };
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to decrypt totals:", e);
      return null;
    }
  }, [contract, fhevmInstance, signer, account, contractAddress]);

  // Get entry count
  const getEntryCount = useCallback(async (): Promise<number> => {
    if (!contract || !account) return 0;
    try {
      const count = await contract.getUserEntryCount(account);
      return Number(count);
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to get entry count:", e);
      return 0;
    }
  }, [contract, account]);

  // Check milestone (returns encrypted boolean that needs to be decrypted)
  const checkMilestone = useCallback(async (
    milestoneId: number,
    threshold: number
  ): Promise<boolean | null> => {
    if (!contract || !fhevmInstance || !signer || !account || !contractAddress) {
      return null;
    }

    try {
      console.log(`[useMirrorPlainWrite] Checking milestone ${milestoneId} with threshold ${threshold}...`);
      
      // Encrypt threshold
      const thresholdInput = fhevmInstance.createEncryptedInput(contractAddress, account);
      thresholdInput.add32(threshold);
      const encryptedThreshold = await thresholdInput.encrypt();

      // Call contract checkMilestone
      const encryptedResult = await contract.checkMilestone(
        milestoneId,
        encryptedThreshold.handles[0],
        encryptedThreshold.inputProof
      );

      // Generate fresh decryption signature
      const { publicKey, privateKey } = fhevmInstance.generateKeypair();
      const sig = await FhevmDecryptionSignature.new(
        fhevmInstance,
        [contractAddress],
        publicKey,
        privateKey,
        signer
      );

      if (!sig) {
        console.error("[useMirrorPlainWrite] Failed to get decryption signature for milestone");
        return null;
      }

      // Decrypt the boolean result
      const decrypted = await fhevmInstance.userDecrypt(
        [{ handle: encryptedResult, contractAddress }],
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      const result = decrypted[encryptedResult] as boolean;
      console.log(`[useMirrorPlainWrite] Milestone ${milestoneId} achieved: ${result}`);
      return result;
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to check milestone:", e);
      return null;
    }
  }, [contract, fhevmInstance, signer, account, contractAddress]);

  // Decrypt all user entries
  const decryptAllEntries = useCallback(async (): Promise<EntryData[]> => {
    if (!contract || !fhevmInstance || !signer || !account || !contractAddress) {
      return [];
    }

    try {
      const count = await contract.getUserEntryCount(account);
      const entryCount = Number(count);

      if (entryCount === 0) {
        return [];
      }

      console.log(`[useMirrorPlainWrite] Decrypting ${entryCount} entries...`);
      console.log("[useMirrorPlainWrite] Generating fresh decryption signature...");

      // Generate new keypair and signature (no cache)
      const { publicKey, privateKey } = fhevmInstance.generateKeypair();
      const sig = await FhevmDecryptionSignature.new(
        fhevmInstance,
        [contractAddress],
        publicKey,
        privateKey,
        signer
      );

      if (!sig) {
        console.error("[useMirrorPlainWrite] Failed to get decryption signature");
        return [];
      }

      // Fetch all entry handles and timestamps
      const entryPromises = Array.from({ length: entryCount }, async (_, index) => {
        const entry = await contract.getUserEntry(account, index);
        return {
          wordsHandle: entry.words,
          durationHandle: entry.duration,
          timestamp: Number(entry.timestamp),
          index,
        };
      });

      const entries = await Promise.all(entryPromises);

      // Prepare handles for batch decryption
      const handles = entries.flatMap(entry => [
        { handle: entry.wordsHandle, contractAddress },
        { handle: entry.durationHandle, contractAddress },
      ]);

      // Batch decrypt all handles
      const decrypted = await fhevmInstance.userDecrypt(
        handles,
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      // Map decrypted values back to entries
      const decryptedEntries: EntryData[] = entries.map((entry) => {
        const words = decrypted[entry.wordsHandle] as bigint;
        const duration = decrypted[entry.durationHandle] as bigint;

        return {
          words: words.toString(),
          duration: duration.toString(),
          timestamp: entry.timestamp,
        };
      });

      console.log(`[useMirrorPlainWrite] Successfully decrypted ${decryptedEntries.length} entries`);
      return decryptedEntries;
    } catch (e) {
      console.error("[useMirrorPlainWrite] Failed to decrypt entries:", e);
      return [];
    }
  }, [contract, fhevmInstance, signer, account, contractAddress]);

  return {
    contract,
    contractAddress,
    isLoading,
    error,
    submitEntry,
    setGoals,
    allowMentor,
    revokeAccess,
    decryptTotals,
    getEntryCount,
    decryptAllEntries,
    checkMilestone,
  };
}

